'''
Warren Koch
V00482478
482A Assignment 3


QUESTION 1:
Find the partition of 100 that has rank 100,000,000. Most likely you will want to write a program in order to solve this problem. 

100000000 [21, 13, 10, 8, 7, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 1, 1]
'''
import math

def P(n,k,t):
    global p, rank, pos
    p[t] = k
    if n==k or k==1:
        if rank%pos==0:
            print(rank,p[1:t+n-k+1])
            pos *=10
        rank+=1
    else:
        for j in range(1,min(k,n-k)+1):
            P(n-k,j,t+1)
    p[t] = 1
    
#MAIN
n = 100
p = [1]*(2*n)
rank = 0
pos = 1
#P(2*n,n,0)
print()
print()

'''
RESULT: 
0 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
10 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
100 [3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
1000 [4, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
10000 [5, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1]
100000 [6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1]
1000000 [8, 8, 5, 5, 5, 5, 5, 4, 4, 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
10000000 [11, 11, 10, 10, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1]
100000000 [21, 13, 10, 8, 7, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 1, 1]

So, Rank 100,000,000 = 21+13+10+8+7+6+6+6+3+3+3+3+3+3+3+1+1

'''

'''
QUESTION 2:
What happens when recursion stops at k=1 in alg 4.3 (instead of n=k)?  Is the resulting algorithm CAT?
'''

def S(n,k):
    global A

    if k==n:
        print(A)
        return
    else:
        for i in range(k):
            A[n-1]=i
            S(n-1,k)
            A[n-1]=n-1
        if k>1:
            A[n-1]=k-1
            S(n-1,k-1)
            A[n-1]=n-1

def S2(n,k):
    global A, count, deadEnds, nodes, Answers
    nodes +=1
    if k==1:
        print(n,k,A)
        Answers.append(str(A))
        count +=1
        return
    if n<1:
        #print(n,k)
        deadEnds +=1
        return
    else:
        for i in range(k):
            A[n-1]=i
            S2(n-1,k)
            A[n-1]=n-1
        if k>1:
            A[n-1]=k-1
            S2(n-1,k-1)
            A[n-1]=n-1




n = 4
k = 2
A = [0]*n
deadEnds = 0
count = 0
nodes = 0
Answers = []
S2(n,k)
print(count, deadEnds, deadEnds/count, nodes)
print(Answers)
print()
print()


'''
ANSWER:
a) Does not produce the same output as n==k. Outputs a list of mostly-Restricted Growth sequences, where each Ai < k (with some exceptions,
e.g. S(4,2)'s last output.  The count of these results matches those of the Stirling Numbers of the Second Kind (A008277)
generated by the function S(n,k) = S(n-1,k-1) + k*S(n-1,k)
This algorithm resembles the process of partitioning elements of an n-set into k nonempty subsets.  However, there are many exceptions.
e.g. S(4,2) outputs "0121", "1111"

b) Definitely not CAT.  e.g. S(6,6)'s parse tree has 106037 nodes and only 21 results.  And it only gets worse as numbers increase.
'''



'''
QUESTION 3:
In the "fence" poset, the Hasse diagram is like a zig-zag.
(a) How many ideals does the fence poset have? For this part you should prove that your answer is correct.
'''

#convention: named with odds on the top, evens on the bottom of the "fence".
def GenIdealFence(k,I):
    global n, W, count
    #W: True if poset shaped like "W" (starting at the top on the left).  Initialized with k=1
    
    if k>=n:
        count +=1
        '''
        if W:
            print("A:", bin(I>>1))
        else:
            print("A:", bin(I))
        '''
    else:
        if k==n-1:
                GenIdealFence(k+1,I|2**k)
                GenIdealFence(k+1,I)
        elif k%2==1:
            GenIdealFence(k+2,I|2**k|2**(k+1))
            GenIdealFence(k+1,I)
        else:
            GenIdealFence(k+1,I|2**k)
            GenIdealFence(k+2,I)


I = 0

for i in range(1,10):
    #check for when poset begins with an even (aka starts at the bottom of a fence post)
    n = i
    count = 0
    W = False
    GenIdealFence(0,I)
    print(count)
    
    #check for when poset begins with an odd (aka starts at the top of the fence) (aka looks like a "W")
    n = i+1
    count = 0
    W = True
    GenIdealFence(1,I)
    print(count)  
          
print()
print()


'''
Results:
2,2,3,3,5,5,8,8,13,13,21,21,34,34,55,55,89,89
AKA The fibonacci numbers F(n) = F(n-1) + F(n-2)

Proof:
Base case: n=0
    One ideal: empty set
n =1:
    Two ideals: empty set, set of one element
n =2:
    Three ideals: Let {x,y} represent poset. w.l.o.g. x<y.  Then ideals
    are {}, {x}, {xy}
Inductive step:  Assume number of ideals I(n) are known for all n<=k
    To find k+1:
    Using formula 4.36 of the textbook, where a formula for Ideals of a poset is given:
       Let Fence poset = P of size n
       Let x be the first element to the left in P, and y be the second
       Case 1: x<y: Then the number of ideals is I(k) (since x has no element less than x. Thus {x union I: I in J(P-{x})} is I(k))
           plus I(k-1), (since y is the only element >x, so J(P-{x,y}) is equal to I(k-1))
           Therefore, # ideals = I(k) + I(k-1)
       Case 2: x>y:  Then # ideals is I(k-1) (Since y is the only element < x, and {{x,y} union I: I in J(P-{x,y})} is I(k-1)
           plus I(k), (since there is no element > x, so J(P-{x}) is I(k))
           Therefore, # ideals = I(k) + I(k-1)
End of Proof

    
'''


'''
(b) How many linear extensions does it have? For this part you should implement an extension generating algorithm (e.g., some version
  of the Varol-Rotem algorithm) to get some numbers, and then plug them into the OEIS. Turn in your program and the OEIS Axxxx number. 
  
  Conventions: "W": Label with 1,2,3...floor(n/2) on the bottom, and floor(n/2)+1 >1,floor(n/2)+2 >1,floor(n/2)+2 >2, etc 
            not "W" : Label with 1,2,3...ceil(n/2) on the bottom, and ceil(n/2)+1 >1,floor(n/2)+1 >2,floor(n/2)+2 >2, etc  
'''

def VRFence(k):
    global n, A, W, count
    if k > n:
        print(A)
        count+=1
    else:
        VRFence(k+1)
        i = k-1 #to compensate for List indexes
        while i > 0 and incom(A[i-1],A[i]):
            t = A[i]
            A[i] = A[i-1]
            A[i-1]=t
            VRFence(k+1)
            i = i-1
        #Rotate
        C = str(A)
        B = A[i:k]
        B.sort()
        A = A[:i] + B + A[k:]
        

def incom(x,y):
    
    global W, A, n
    t = 0
    if y<x:
        t = y
        y=x
        x=t
    
    if W:
        half = math.floor(n/2)
        r=1
    else:
        half = math.ceil(n/2)
        r = 0
        
    b = True
    if (y-half-x-r in [-1,0]):
        b = False
    if (y<=half and x<=half) or (y>half and x>half):
        b = True   
    
    return b
        
    
n = 5
A = [i for i in range(1,n+1)]
count = 0
W = False # convention that poset starts with first element at the top ("w" shaped poset)
VRFence(1)
print(count)
print()
print()

''' 
ANSWER: A000111    Euler or up/down numbers: expansion of sec x + tan x . Also number of alternating permutations on n letters. 
'''